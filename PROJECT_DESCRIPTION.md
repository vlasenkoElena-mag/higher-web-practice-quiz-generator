# Проект «Генератор тестов»

## Описание проекта
Помните различные квизы в уроках на платформе Практикума? Вам предстоит реализовать схожий генератор тестов с возможностью множественного или одиночного выбора ответа.

### Что нужно сделать

Ваша задача — создать приложение, которое позволяет загружать данные теста в формате JSON через текстовое поле, сохранять тесты в IndexedDB и проходить их. Приложение должно состоять из трёх страниц.

### Подготовка к работе
Прежде чем приступить к выполнению работы, ознакомьтесь с [макетом](https://www.figma.com/design/RMmqqTjaKB3bghr5PvDCS9/%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%E2%80%A8%C2%AB%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2%C2%BB?node-id=12-4354&p=f&t=xRUK29SW7mSgYJ2W-0), [шаблоном](https://github.com/yandex-praktikum/higher-web-practice-quiz-generator) и структурой данных для теста. Для запуска проекта вам предстоит настроить сборщик Vite. Все тесты проекта должны храниться в формате JSON со следующей структурой:

```json
{
  "title": "Название теста",
  "questions": [
    {
      "id": 1,
      "text": "Текст вопроса",
      "type": "single", // или "multiple" для множественного выбора
      "options": [
        {"id": 1, "text": "Вариант ответа 1", "correct": true, "message": "Этот ответ правильный" },
        {"id": 2, "text": "Вариант ответа 2", "correct": false, "message": "Этот ответ неправильный"}
      ]
    }
  ]
}
```
## Функциональные требования
### Технологический стек:
- HTML
- CSS
- JavaScript
- Vite в качестве сборщика
- Другие необходимые библиотеки (nanoId, zod, idb)
### Организация кода и файловая структура
- Проект должен быть многостраничным: index.html, quizzes.html, quiz.html.
- Общие стили (сброс стилей, переменные, шрифты, цвета) должны находиться в директории css в файлах по типу variables.css, base.css.
- Стили для компонентов (кнопка, модальное окно, форма вопроса) должны быть в отдельных файлах в папке css/components.
- Скрипты для функциональности страниц должны быть в отдельных файлах в папке js/.
- Изображения и иконки должны храниться в папке assets.
### Адаптивность
- Приложение должно корректно отображаться на мобильных устройствах (от 320px), планшетах и десктопах.
### Семантика и доступность
- Использование семантических тегов (header, main, nav, section).
- Корректная структура заголовков.
- Доступность форм и интерактивных элементов.
### Главная страница (index.html)
- Textarea для ввода JSON с моноширинным шрифтом.
- Кнопка «Сгенерировать»
- Валидация JSON:
  - Для валидации JSON необходимо использовать библиотеку Zod.
  - При успешном парсинге и соответствии JSON структуре данных должен быть переход на страницу со списком тестов.
  - При ошибке должно показываться сообщение в модальном окне.
- В Header должна быть ссылка на страницу со списком тестов.
### Страница со списком тестов (quizzes.html)
- Должны отображаться карточки всех тестов, сохранённых в IndexedDB.
- Карточка теста должна содержать:
  - название теста,
  - описание теста,
  - количество вопросов,
  - кнопка перехода на страницу теста.
- В Header должна быть ссылка на главную страницу.
### Страница прохождения теста (quiz.html)
- Поддержка различных типов вопросов:
  - одиночный выбор (radio);
  - множественный выбор (checkbox).
- Должен отображаться прогресс-бар с номером текущего вопрос и общим количеством вопросов в тесте.
- id теста должен содержаться в URL.
- Номер текущего вопроса должен отображаться в URL в SearchParams.
- При клике на кнопку «Ответить»:
  - Должна проводиться валидация ответа.
  - Должна отображаться корректность ответа.
  - Текст кнопки должен меняться на «Следующий вопрос». Если вопрос последний, то текст должен меняться на «Завершить тест».
- При клике на кнопку «Следующий вопрос»:
  - Должен меняться текущий вопрос в прогресс-баре и в URL.
  - Должен отображаться следующий вопрос.
- При клике на кнопку «Завершить тест» должно отображаться модальное окно с результатами теста и кнопками «К списку квизов» и «Пройти снова».
## Структура проекта
```bash
.
├── assets
│   └── logo.svg
├── css
│   ├── base
│   │   ├── base.css
│   │   └── variables.css
│   ├── components
│   │   ├── header.css
│   │   └── toast.css
│   └── pages
│       ├── index.css
│       ├── quiz.css
│       └── quizzes.css
├── index.html
├── js
│   ├── components
│   │   └── header.js
│   ├── pages
│   │   ├── main.js
│   │   ├── quiz.js
│   │   └── quizzes.js
│   └── utils
│       ├── storage.js
│       └── validation.js
├── package.json
├── package-lock.json
├── quiz-examples
│   ├── css-quiz.json
│   ├── html-quiz.json
│   ├── js-quiz.json
│   └── toolz-quiz.json
├── quiz.html
├── quizzes.html
└── vite.config.js
```
Мы заранее подготовили для вас несколько простых тестов, которые вы можете использовать для разработки. Они находятся в директории `quiz-examples/.`

## Настройка Vite

Vite — это современный сборщик для веб-приложений, который обеспечивает:
- молниеносную горячую перезагрузку (HMR);
- оптимизированную сборку для продакшена;
- простую настройку и работу с ES-модулями.
Вам предстоит самим настроить сборку Vite. Для этого существует документация, а также мы подготовили для вас несколько советов.

Конфиг должен находиться в корне директории в файле `vite.config.js`. Вам нужно импортировать функцию `defineConfig` из пакета `vite`, затем указать нужные параметры:
- `base: './'` — базовый путь для относительных URL.
- `server` — настройки dev-сервера (порт и автозапуск браузера).
- `build.outDir` — место, куда будет собираться ваше приложение.
- `build.rollupOptions.input` — multi-page конфигурация для нескольких HTML-страниц.
- `optimizeDeps.include` — предварительная сборка зависимостей.
После того как настроите конфиг сборки, нужно собрать и запустить проект:
```bash
# Установка зависимостей
npm install

# Запуск в режиме разработки
npm run dev

# Сборка для продакшена
npm run build
```
## Работа с IndexedDB
Сохранять данные на клиенте мы могли бы и в localStorage, для этого даже есть несколько способов:

- Мы можем сохранять каждый квиз под своим уникальным идентификатором, например:
```javascript
import { nanoid } from 'nanoid';

function saveQuiz(quiz) {
  window.localStorage.setItem(nanoid(), JSON.stringify(quiz));
}

function getQuizzes() {
  const quizzes = [];

  Object.keys(window.localStorage).forEach(key => {
    const value = localStorage.getItem(key);
    quizzes.push(value);
  });

  return quizzes;
}
```
	Но такой вариант не очень удобен: возможно, вы захотите сохранять ещё какие-то данные в localStorage, и тогда вам необходимо будет дополнительно фильтровать выборку ключей.

- Использовать единый ключ для всех тестов, например `quizzes`. Таким образом все тесты будут храниться в одном месте и никак не будут пересекаться с другими данными в localStorage. Однако это не очень эффективно: каждый раз при добавлении нового теста вам нужно будет получить весь список тестов из localStorage, распарсить строку, добавить элемент и снова сохранить в локальном хранилище.

Хорошего решения с localStorage нет: это хранилище рассчитано на простые данные небольшого объёма, а не на большие массивы объектов. Для этого есть более оптимальные варианты.

IndexedDB — это низкоуровневое API для клиентского хранилища большого объёма структурированных данных. Эти API используют индексы для обеспечения высокопроизводительного поиска данных. Подробнее про IndexedDB можете прочитать в Доке и MDN.

Преимущества IndexedDB перед localStorage:
- больший объём хранения,
- асинхронные операции,
- возможность сложных запросов,
- лучшая производительность для больших объёмов данных.
Нативное API IndexedDB может показаться сложным и неудобным, но эта проблема решается использованием сторонних библиотек, таких как idb.
Вот небольшой пример использования idb. Сначала создадим базу данных для тестов:
```javascript
// ./js/utils/db.js

import { openDB } from 'idb';

export const dbPromise = openDB('quizzes-db', 1, {
  upgrade(db) {
    db.createObjectStore('quizzes', { keyPath: 'id' });
  },
});
```

Разберём, что происходит в этом коде:
1. `openDB('quizzes-db', 1, ...)` — открываем/создаём базу данных:
- 'quizzes-db' — название базы данных;
- `1` — версия базы.
2. `upgrade(db)` — функция, которая выполняется при создании/обновлении базы:
- `db` — объект базы данных.
3. `db.createObjectStore('quizzes', { keyPath: 'id' })` — создаём таблицу:
- `'quizzes'` — название хранилища (похоже на таблицу в SQL);
- `{ keyPath: 'id' }` — указываем, что поле id будет ключом для записей.
-
Более простыми словами: мы создаём в IndexedDB базу данных `'quizzes-db'`, в ней создаём таблицу `'quizzes'`, каждая запись в этой таблице будет содержать уникальный id; `dbPromise` — это промис, предоставляющий доступ к базе данных.
Пример использования `dbPromise`:
```javascript
// ./js/utils/storage.js

import { dbPromise } from './db.js';
import { nanoid } from 'nanoid';

export async function saveQuiz(quizData) {
  const db = await dbPromise;
  return db.put('quizzes', { id: nanoid(), ...quizData });
}

export async function getQuiz(id) {
  const db = await dbPromise;
  return db.get('quizzes', id);
}

export async function getAllQuizzes() {
  const db = await dbPromise;
  return db.getAll('quizzes');
}

export async function deleteQuiz(id) {
  const db = await dbPromise;
  return db.delete('quizzes', id);
}

export async function clearAllQuizzes() {
  const db = await dbPromise;
  return db.clear('quizzes');
}
```

Как вы могли заметить, наш формат JSON не содержит в себе какого-либо уникального идентификатора. Для генерации уникального идентификатора обычно используется библиотека [uuid](https://www.npmjs.com/package/uuid), но мы будем использовать более лёгкую и простую библиотеку [nanoid](https://www.npmjs.com/package/nanoid).

## Валидация JSON
Реализуйте валидацию вводимого в `textarea` JSON:
```javascript
export function validateQuizJson(jsonString) {
  try {
    // проверка JSON
    return { isValid: true, data };
  } catch (error) {
    return { isValud: false, error: error.message };
  }
}
```
Хоть мы и можем валидировать строку методом `JSON.parse()`, этот метод проверит только то, что строка может быть валидным JSON и не пропустит, например, строку `hello i'm JSON, trust me`. Но в то же время он не выдаст никаких ошибок, если туда будет передана строка `null`. Для лучшей валидации вам нужно будет проверять, что JSON не является `null`, проверять наличие каждого нужного поля в JSON и соответствие каждого значения поля всем нужным нам типам. В этом случае придётся написать множество строчек кода. Но в мире JavaScript уже существует много готовых решений. Для валидации мы будем использовать такой инструмент для валидации, как zod.
Zod — это библиотека для создания схем валидации. Хотя она разработана для TypeScript, но отлично работает и с чистым JavaScript. Вы создаёте схему — описание того, как должны выглядеть ваши данные. Zod проверяет, соответствуют ли им реальные данные.
Посмотрите, как валидировать объект пользователя без zod и с помощью zod:
```typescript
// без zod

function validateUser(data) {
  if (typeof data.id !== 'number') return false;
  if (typeof data.name !== 'string' || data.name.length < 2) return false;
  if (typeof data.email !== 'string' || !data.email.includes('@')) return false;
  if (data.age && typeof data.age !== 'number') return false;
  return true;
}
```
```typescript
// с zod

import { z } from 'zod';

const User = z.object({
  id: z.number(),
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().min(0).optional(),
});

const parsedUser = User.safeParse(userData);
if (parsedUser.success) {
  // Данные валидны
}
```
Zod делает валидацию проще, надёжнее и нагляднее.
Таким образом, вам нужно будет создать схему теста, распарсить строку в JSON, проверить JSON на соответствие схеме. Если всё ок, то вернуть объект; иначе вернуть ошибку.

## Компоненты для вопросов
Создайте компоненты для одиночного и множественного выбора:
```html
<!-- В quiz.html -->
<template id="single-question-template">
  <div class="question" data-type="single">
    <h3 class="question__text"></h3>
    <p class="question__hint">Выберите один вариант ответа</p>
    <div class="question__options"></div>
  </div>
</template>

<template id="multiple-question-template">
  <div class="question" data-type="multiple">
    <h3 class="question__text"></h3>
    <p class="question__hint">Выберите один или несколько вариантов ответа</p>
    <div class="question__options"></div>
  </div>
</template>

<template id="option-template">
  <label class="option">
    <input type="radio" name="question" value="" />
    <span class="option__text"></span>
  </label>
</template>

<template id="checkbox-option-template">
  <label class="option">
    <input type="checkbox" name="question" value="" />
    <span class="option__text"></span>
  </label>
</template>
```
Для этого вы можете использовать уже знакомый тег `<template>`.
### Проверка правильного ответа
Для проверки правильного ответа реализуйте функцию, которая принимает в себя текущий вопрос и вариант ответа, который может быть или массивом, или строкой и возвращать список типа:
```javascript
{
  "isCorrect": true, // или false, если ответ на вопрос неверный
  "texts": [ // массив текстов для отображения в форме
    {
      "id": 1,
      "message": "Текст ошибки или успеха",
      "isSuccess": true // или false, если это текст ошибки
    }
  ]
}
```
При клике на кнопку «Ответить» вы должны вызывать событие формы `submit`. В этом событии вы должны проверить, был ли выбран вариант ответа: если был, то проверить корректность ответа, отобразить ответ пользователя и правильный ответ, скрыть кнопку «Отправить» и отобразить кнопку «Следующий вопрос». Не забывайте сохранять в счётчик количество правильных ответов, чтобы затем отобразить их пользователю в окне результатов.
## Требования к оформлению работы
В корневой файл `README.md` обязательно добавьте:
- Ссылку на репозиторий GitHub с вашей работой.
- Ваше имя и курс.
- Ссылку на опубликованную версию (при наличии).
- Инструкцию по запуску проекта.

# Чек-лист проверки
## Критические требования
- При открытии любой страницы в консоли браузера нет ошибок JavaScript.
- Все основные функции работают (создание теста, список тестов, прохождение теста).
- Приложение адаптивно для мобильных устройств.
- Данные корректно сохраняются в IndexedDB.
## Требования к коду
- Единообразное форматирование во всех файлах.
- Использование const и let вместо var.
- Осмысленные имена переменных и функций в camelCase.
- CSS-классы по методологии БЭМ.
- Разделение кода на модули.
- Подключение только необходимых стилей и скриптов на каждой странице.
## Функциональность
- Главная страница
  - Валидация JSON с понятными сообщениями об ошибках.
  - Корректный переход при успешном создании теста.
  - Ссылка на список существующих тестов.
  - Toast-уведомления для ошибок.
- Страница списка тестов
  - Отображение всех тестов из IndexedDB в адаптивной сетке.
  - Корректные ссылки на страницы прохождения.
  - Если тестов нет, то должна отображаться заглушка.
- Страница прохождения теста
  - Корректное отображение разных типов вопросов с использованием template.
  - Валидация ответов и подсчёт результатов.
  - Плавная навигация между вопросами.
  - Итоговое модальное окно с результатами.
  - Прогресс-бар и обновление URL.


# Баллы
## Критерий 1: Архитектура, сборка и организация кода
0	Нет многостраничности; Vite не настроен или не работает; структура проекта не соответствует ТЗ; скрипты/стили не разделены; на страницах подключены лишние ресурсы; используется var.
1	Структура частично соблюдена; Vite работает, но с ошибками; компоненты вынесены, но с нарушениями; форматирование местами разное; let/const в основном, но есть исключения.
2	Три HTML-страницы; Vite настроен корректно (base, входы, сборка); структура — как в ТЗ; стили и скрипты — по папкам; на каждой странице — только нужные ресурсы; единообразное форматирование; только let/const.
## Критерий 2: Валидация и работа с данными
0	JSON валидируется только через JSON.parse; нет Zod-схемы; ошибки не обрабатываются; нет генерации id; IndexedDB не используется; данные не сохраняются.
1	Zod частично применён; схема есть, но без полной проверки типов/полей; id генерируется; IndexedDB работает, но без библиотеки idb или с ошибками (данные не сохраняются или не возможно их получить из хранилища).
2	Валидация через Zod с полной схемой (title, questions, options, типы); ошибки отображаются в модалке/toast; id генерируется через nanoid; данные сохраняются и читаются из IndexedDB через idb.
## Критерий 3: Страницы — главная и список тестов
0	Нет textarea с моноширинным шрифтом; кнопка «Сгенерировать» не работает; на quizzes.html — не отображаются тесты из IndexedDB; нет ссылок в header; при пустом списке — нет заглушки.
1	Сообщения валидации непонятны; тесты отображаются, но без описания/количества вопросов; ссылки работают, но без адаптивной сетки.
2	Главная: textarea, кнопка, переход при успехе, ссылка в header, toast при ошибках; Список: карточки с названием, описанием, кол-вом вопросов, кнопкой; адаптивная сетка; заглушка при пустом списке; ссылка в header.
## Критерий 4: Страница прохождения теста
0	Не поддерживаются типы вопросов; нет шаблонов (template); прогресс-бар отсутствует; URL не обновляется; валидация ответов сломана; результаты не считаются; нет модального окна завершения.
1	Шаблоны есть, но не через template; прогресс-бар и URL работают частично; валидация есть, но без feedback (сообщений); результаты считаются, но без детализации.
2	Используются radio/checkbox для single/multiple; корректный рендер; прогресс-бар и SearchParams в URL обновляются; при ответе — проверка, сообщения (message), изменение кнопки; при завершении — модальное окно с результатами и кнопками.
## Критерий 5: Адаптивность, семантика и доступность
0	Сайт не адаптивен (ломается на мобиле); используются div вместо header/main/section; заголовки не по иерархии; формы без label; интерактив без фокуса.
1	Адаптивность есть, но с багами; семантика в основном соблюдена; заголовки в порядке;
2	Корректное отображение от 320px до десктопа; использованы header, main, nav, section; заголовки по структуре; формы с label; интерактивные элементы доступны с клавиатуры и имеют визуальный фокус.
## Критерий 6: Стиль кода и именование
0	Имена с транслитом/сокращениями; CSS-классы не по БЭМ; функции без глаголов; массивы не во мн. числе; имена не отражают содержимое.
1	Отдельные нарушения: редкие сокращения, БЭМ местами нарушен, имена в основном осмысленные.
2	Имена переменных/функций — camelCase, осмысленные (существительные/глаголы); массивы — во мн. числе; CSS — строго по БЭМ; без транслита и неуместных сокращений.